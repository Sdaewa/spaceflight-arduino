var lcd,
    messages,
    lcd_info,
    anim_settings,
    debug,
    timeout;

/**
 *  Setup the lcd object we need to
 *  interact with the actual LCD
 *
 *  @param ( object ) _obj - Must be the lcd object or { lcd: lcd, extraParam... } object minimum
 */
module.exports.setup = function( _obj ){

    lcd = _obj.lcd || _obj;

    /* Start clean */
    lcd.clear();

    /* each item of the array is a line */
    messages = [];

    /* Some basic info we could get from the lcd object actually */
    lcd_info = {
        char_length: _obj.char_length || 16, /* Number of characters per line */
        row: _obj.row || 2 /* Number of lines */
    };

    /* Animation setup */
    anim_settings = {
        firstCharPauseDuration: _obj.firstCharPauseDuration || 4000, /* Time before animation start */
        lastCharPauseDuration: _obj.lastCharPauseDuration || 1000, /* Time once animation done */
        scrollingDuration: _obj.scrollingDuration || 300, /* Step time during animation */
        full: true /* Extend message until it completely disapears from the screen */
    };

    if( _obj.full === false ){
        anim_settings.full = false;
    }

    /* Will generate console logs if set to true */
    debug = _obj.debug || false;

};

/**
 *  Throw error if debug mode enabled
 *
 *  @param (string) _msg - Message to display
 */
function error( _msg ){

    if( debug ){

        console.log( '[Error:: LCD_Scrolling] ' + _msg );

    }

}

/**
 *  Incremente progress or reset if done.
 *
 *  @param (int) _line - Line index
 */
function progress( _line ){

    messages[ _line ].progress++;

    if( (messages[ _line ].progress + messages[ _line ].diff) > 0 ){

        messages[ _line ].progress = 0;

    }

}

/**
 *  Animate the text on screen
 *
 *  @param (int) _line - Line index
 */
function anim( _line ){

    var msg = messages[ _line ];

    lcd.cursor( _line, 0 );

    if( msg.progress === 0 ){

        lcd.print( msg.msg );

        progress( _line );

        (function( _line ){
            timeout = setTimeout(function(){
                anim( _line )
            }, anim_settings.firstCharPauseDuration );
        })( _line );

    }else{

        lcd.print( msg.msg.substr( msg.progress ) );

        progress( _line );

        (function( _line ){

            var time = anim_settings.scrollingDuration;

            if( messages[ _line ].progress === 0 ){
                time = anim_settings.lastCharPauseDuration;
            }

            timeout = setTimeout( function(){
                anim( _line );
            }, time );

        })( _line );

    }
}

/**
 *  Setup the message for a specific line
 *
 *  @param (int)_line       - line number (start at index 0)
 *  @param (string)_message - message to display
 */
module.exports.line = function( _line, _message ){

    /* Line number is not recognised as a number */
    if( isNaN( _line ) ){

        error( 'Line is NaN' );
        return;

    }

    /* Line number not in the limit of the row number setup in the lcd */
    if( _line >= lcd_info.row ){

        error( 'Row over capacity' );
        return;

    }

    messages[ _line ] = {
        msg: _message,
        diff: lcd_info.char_length - _message.length,
        progress: 0
    };

    if( messages[ _line ].diff >= 0 ){

        /* We fill the gap with space to be sure to override previous messages */
        for( var i = 0; i < messages[ _line ].diff; i++ ){
            messages[ _line ].msg += ' ';
        }

        lcd.cursor( _line, 0 ).print( messages[ _line ].msg );

    }else if( messages[ _line ].diff < 0 ){

        if( anim_settings.full ){

            for( var i = 0; i < lcd_info.char_length; i++ ){

                messages[ _line ].msg += ' ';
                messages[ _line ].diff--;
            }

        }

        anim( _line );

    }
},

module.exports.clear = function() {
    if (lcd) {
        clearTimeout(timeout);
        lcd.clear();
        messages = [];
    }    
}
